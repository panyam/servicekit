<!DOCTYPE html>
<html>
<head>
    <title>gRPC-WebSocket Demo</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; background: #f5f5f5; }
        h1 { color: #333; }
        .section { background: white; border: 1px solid #ddd; padding: 15px; margin: 15px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .section h3 { margin-top: 0; color: #2196F3; }
        .section p { color: #666; margin-bottom: 15px; }
        button { padding: 8px 16px; margin: 5px 5px 5px 0; cursor: pointer; border: none; border-radius: 4px; font-size: 14px; }
        .connect { background: #4CAF50; color: white; }
        .connect:hover { background: #45a049; }
        .disconnect { background: #f44336; color: white; }
        .disconnect:hover { background: #da190b; }
        .send { background: #2196F3; color: white; }
        .send:hover { background: #1976D2; }
        input { padding: 8px 12px; margin: 5px 5px 5px 0; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        .log { background: #1e1e1e; color: #d4d4d4; padding: 12px; height: 200px; overflow-y: auto;
               font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; border-radius: 4px; margin-top: 10px; }
        .log .error { color: #f44336; }
        .log .info { color: #4CAF50; }
        .log .data { color: #64B5F6; }
        .log .ping { color: #9E9E9E; }
        .status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
        .status.connected { background: #4CAF50; }
        .status.disconnected { background: #f44336; }
        code { background: #e0e0e0; padding: 2px 6px; border-radius: 3px; font-size: 13px; }
        .client-info { background: #e3f2fd; border: 1px solid #bbdefb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <h1>gRPC-WebSocket Demo</h1>
    <p>This demo shows the <code>grpcws</code> package for gRPC streaming over WebSocket using real protobuf messages.</p>

    <div class="client-info">
        Using <code>@panyam/servicekit-client</code> library - GRPCWSClient handles protocol automatically (ping/pong, envelope wrapping).
    </div>

    <div class="section">
        <h3><span class="status disconnected" id="subscribe-status"></span>Server Streaming: Subscribe to Game Events</h3>
        <p>Pattern: <code>rpc Subscribe(SubscribeRequest) returns (stream GameEvent)</code><br>
           Server pushes game events (score updates) every 2 seconds. Client only receives.</p>
        <input type="text" id="subscribe-game-id" value="game123" placeholder="Game ID" style="width: 100px;">
        <input type="text" id="subscribe-player-id" value="player1" placeholder="Player ID" style="width: 100px;">
        <button class="connect" onclick="connectSubscribe()">Connect</button>
        <button class="disconnect" onclick="disconnectSubscribe()">Disconnect</button>
        <div id="subscribe-log" class="log"></div>
    </div>

    <div class="section">
        <h3><span class="status disconnected" id="commands-status"></span>Client Streaming: Send Commands</h3>
        <p>Pattern: <code>rpc SendCommands(stream GameCommand) returns (CommandSummary)</code><br>
           Client sends multiple commands. When done, server returns a summary of executed commands.</p>
        <input type="text" id="command-type" value="attack" placeholder="Command type" style="width: 100px;">
        <button class="connect" onclick="connectCommands()">Connect</button>
        <button class="send" onclick="sendCommand()">Send Command</button>
        <button class="send" onclick="endCommands()">End Stream</button>
        <button class="disconnect" onclick="disconnectCommands()">Disconnect</button>
        <div id="commands-log" class="log"></div>
    </div>

    <div class="section">
        <h3><span class="status disconnected" id="sync-status"></span>Bidirectional Streaming: Game Sync</h3>
        <p>Pattern: <code>rpc SyncGame(stream PlayerAction) returns (stream GameState)</code><br>
           Full duplex: client sends player actions, server responds with updated game state.</p>
        <input type="text" id="sync-player-id" value="player1" placeholder="Player ID" style="width: 100px;">
        <button class="connect" onclick="connectSync()">Connect</button>
        <button class="send" onclick="sendMove()">Move</button>
        <button class="send" onclick="sendAttack()">Attack</button>
        <button class="send" onclick="sendUseItem()">Use Item</button>
        <button class="disconnect" onclick="disconnectSync()">Disconnect</button>
        <div id="sync-log" class="log"></div>
    </div>

    <!-- Load the ServiceKit client library -->
    <script src="/servicekit-client.js"></script>

    <script>
        // Use the ServiceKit client library
        const { GRPCWSClient } = ServiceKit;

        let subscribeClient = null, commandsClient = null, syncClient = null;
        let commandNum = 0, actionNum = 0;

        function setStatus(id, connected) {
            document.getElementById(id).className = 'status ' + (connected ? 'connected' : 'disconnected');
        }

        function log(elementId, msg, type = '') {
            const el = document.getElementById(elementId);
            const line = document.createElement('div');
            line.className = type;
            line.textContent = new Date().toLocaleTimeString() + ' ' + msg;
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
            while (el.children.length > 100) el.removeChild(el.firstChild);
        }

        // Subscribe (Server Streaming)
        function connectSubscribe() {
            if (subscribeClient) subscribeClient.close();

            const gameId = document.getElementById('subscribe-game-id').value || 'game123';
            const playerId = document.getElementById('subscribe-player-id').value || 'player1';

            subscribeClient = new GRPCWSClient();

            subscribeClient.onMessage = (data) => {
                log('subscribe-log', 'Data: ' + JSON.stringify(data), 'data');
            };

            subscribeClient.onStreamEnd = () => {
                log('subscribe-log', 'Stream ended', 'info');
            };

            subscribeClient.onError = (error) => {
                log('subscribe-log', 'Error: ' + error, 'error');
            };

            subscribeClient.onClose = () => {
                log('subscribe-log', 'Disconnected', 'error');
                setStatus('subscribe-status', false);
            };

            subscribeClient.onPing = (pingId) => {
                log('subscribe-log', 'Ping ' + pingId, 'ping');
            };

            subscribeClient.connect('ws://' + location.host + '/ws/v1/subscribe')
                .then(() => {
                    log('subscribe-log', 'Connected', 'info');
                    setStatus('subscribe-status', true);
                    // Send initial subscribe request
                    subscribeClient.send({ gameId: gameId, playerId: playerId });
                    log('subscribe-log', 'Subscribed to game: ' + gameId, 'info');
                })
                .catch(err => {
                    log('subscribe-log', 'Connection failed: ' + err, 'error');
                });
        }

        function disconnectSubscribe() {
            if (subscribeClient) {
                subscribeClient.close();
                subscribeClient = null;
            }
        }

        // Commands (Client Streaming)
        function connectCommands() {
            if (commandsClient) commandsClient.close();
            commandNum = 0;

            commandsClient = new GRPCWSClient();

            commandsClient.onMessage = (data) => {
                log('commands-log', 'Data: ' + JSON.stringify(data), 'data');
            };

            commandsClient.onStreamEnd = () => {
                log('commands-log', 'Stream ended', 'info');
            };

            commandsClient.onError = (error) => {
                log('commands-log', 'Error: ' + error, 'error');
            };

            commandsClient.onClose = () => {
                log('commands-log', 'Disconnected', 'error');
                setStatus('commands-status', false);
            };

            commandsClient.onPing = (pingId) => {
                log('commands-log', 'Ping ' + pingId, 'ping');
            };

            commandsClient.connect('ws://' + location.host + '/ws/v1/commands')
                .then(() => {
                    log('commands-log', 'Connected - send commands then click "End Stream"', 'info');
                    setStatus('commands-status', true);
                })
                .catch(err => {
                    log('commands-log', 'Connection failed: ' + err, 'error');
                });
        }

        function sendCommand() {
            if (!commandsClient || !commandsClient.isConnected) {
                log('commands-log', 'Not connected', 'error');
                return;
            }
            commandNum++;
            const cmdType = document.getElementById('command-type').value || 'attack';
            const cmd = {
                commandId: 'cmd-' + commandNum,
                commandType: cmdType,
                timestamp: Date.now(),
                parameters: { target: 'enemy-' + (commandNum % 5) }
            };
            commandsClient.send(cmd);
            log('commands-log', 'Sent command: ' + cmdType + ' (cmd-' + commandNum + ')', 'info');
        }

        function endCommands() {
            if (!commandsClient || !commandsClient.isConnected) {
                log('commands-log', 'Not connected', 'error');
                return;
            }
            commandsClient.endSend();
            log('commands-log', 'Requested summary...', 'info');
        }

        function disconnectCommands() {
            if (commandsClient) {
                commandsClient.close();
                commandsClient = null;
            }
        }

        // Sync (Bidirectional Streaming)
        function connectSync() {
            if (syncClient) syncClient.close();
            actionNum = 0;

            syncClient = new GRPCWSClient();

            syncClient.onMessage = (data) => {
                log('sync-log', 'Data: ' + JSON.stringify(data), 'data');
            };

            syncClient.onStreamEnd = () => {
                log('sync-log', 'Stream ended', 'info');
            };

            syncClient.onError = (error) => {
                log('sync-log', 'Error: ' + error, 'error');
            };

            syncClient.onClose = () => {
                log('sync-log', 'Disconnected', 'error');
                setStatus('sync-status', false);
            };

            syncClient.onPing = (pingId) => {
                log('sync-log', 'Ping ' + pingId, 'ping');
            };

            syncClient.connect('ws://' + location.host + '/ws/v1/sync')
                .then(() => {
                    log('sync-log', 'Connected - send actions to see game state updates', 'info');
                    setStatus('sync-status', true);
                })
                .catch(err => {
                    log('sync-log', 'Connection failed: ' + err, 'error');
                });
        }

        function sendAction(action) {
            if (!syncClient || !syncClient.isConnected) {
                log('sync-log', 'Not connected', 'error');
                return;
            }
            actionNum++;
            const playerId = document.getElementById('sync-player-id').value || 'player1';
            const msg = {
                actionId: 'action-' + actionNum,
                playerId: playerId,
                timestamp: Date.now(),
                ...action
            };
            syncClient.send(msg);
        }

        function sendMove() {
            sendAction({ move: { x: Math.random() * 100, y: 0, z: Math.random() * 100 } });
            log('sync-log', 'Sent: Move', 'info');
        }

        function sendAttack() {
            sendAction({ attack: { targetId: 'enemy-1', weaponId: 'sword' } });
            log('sync-log', 'Sent: Attack', 'info');
        }

        function sendUseItem() {
            sendAction({ useItem: { itemId: 'potion-1', targetId: 'self' } });
            log('sync-log', 'Sent: Use Item', 'info');
        }

        function disconnectSync() {
            if (syncClient) {
                syncClient.close();
                syncClient = null;
            }
        }
    </script>
</body>
</html>
